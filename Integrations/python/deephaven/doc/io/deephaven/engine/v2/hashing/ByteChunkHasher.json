{
 "className": "io.deephaven.engine.v2.hashing.ByteChunkHasher",
 "methods": {
  "hashInitial": "**Incompatible overloads text - text from the first overload:**\n\nCalled for the first (or only) hash value, sets the hash codes in destination corresponding to values.\n\n*Overload 1*  \n  :param value: (java.lang.Object) - the boxed object to hash\n  :return: (int) the hashcode, as if you called the chunked version of this function\n  \n*Overload 2*  \n  :param values: (io.deephaven.engine.chunk.Chunk<io.deephaven.engine.chunk.Attributes.Values>) - the values to hash\n  :param destination: (io.deephaven.engine.chunk.WritableIntChunk<io.deephaven.engine.chunk.Attributes.HashCode>) - the chunk to write hash values into",
  "hashUpdate": "**Incompatible overloads text - text from the first overload:**\n\nCalled for subsequent hash values, updates the hash codes in destination corresponding to values.\n\n*Overload 1*  \n  :param existing: (int) - the existing hashcode\n  :param value: (java.lang.Object) - the boxed object to add to the hash code\n  :return: (int) the hashcode, as if you called the chunked version of this function\n  \n*Overload 2*  \n  :param values: (io.deephaven.engine.chunk.Chunk<io.deephaven.engine.chunk.Attributes.Values>) - the values to hash\n  :param destination: (io.deephaven.engine.chunk.WritableIntChunk<io.deephaven.engine.chunk.Attributes.HashCode>) - the chunk to update hash values into"
 },
 "path": "io.deephaven.engine.v2.hashing.ByteChunkHasher",
 "typeName": "class"
}